use std::{
    collections::HashSet,
    env, fs,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{anyhow, Context, Result};
use serde_json::{json, Value};
use tempfile::NamedTempFile;
use tracing::debug;
use which::which;

use substrate_common::manager_manifest::{DetectSpec, ManagerManifest, ManagerSpec, Platform};

const SNIPPET_HEADER: &str = "# Generated by Substrate â€“ do not edit\n";

#[derive(Debug, Clone)]
pub struct ManifestPaths {
    pub base: PathBuf,
    pub overlay: Option<PathBuf>,
}

#[derive(Debug, Clone)]
pub struct ManagerInitConfig {
    pub skip_all: bool,
    pub skip_list: HashSet<String>,
    pub platform: Platform,
    pub debug: bool,
}

impl ManagerInitConfig {
    pub fn from_env(platform: Platform) -> Self {
        let skip_all = env::var("SUBSTRATE_SKIP_MANAGER_INIT")
            .map(|value| is_truthy(&value))
            .unwrap_or(false);
        let skip_list = env::var("SUBSTRATE_SKIP_MANAGER_INIT_LIST")
            .ok()
            .map(|value| parse_skip_list(&value))
            .unwrap_or_default();
        let debug = env::var("SUBSTRATE_MANAGER_INIT_DEBUG")
            .map(|value| is_truthy(&value))
            .unwrap_or(false);

        Self {
            skip_all,
            skip_list,
            platform,
            debug,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ManagerState {
    pub name: String,
    pub detected: bool,
    pub reason: Option<String>,
    pub snippet: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ManagerInitResult {
    pub states: Vec<ManagerState>,
    pub snippet: String,
    pub skipped: bool,
}

pub fn detect_and_generate(
    manifest_paths: ManifestPaths,
    cfg: ManagerInitConfig,
) -> Result<ManagerInitResult> {
    if cfg.skip_all {
        let snippet = format!(
            "{}# Manager init disabled via SUBSTRATE_SKIP_MANAGER_INIT\n",
            SNIPPET_HEADER
        );
        return Ok(ManagerInitResult {
            states: Vec::new(),
            snippet,
            skipped: true,
        });
    }

    let manifest = ManagerManifest::load(&manifest_paths.base, manifest_paths.overlay.as_deref())
        .with_context(|| {
        format!(
            "failed to load manager manifest at {}",
            manifest_paths.base.display()
        )
    })?;

    let specs = manifest.resolve_for_platform(cfg.platform);
    let mut states = Vec::with_capacity(specs.len());
    for spec in specs {
        states.push(evaluate_manager(spec, &cfg));
    }

    let snippet = build_snippet(&states);
    Ok(ManagerInitResult {
        states,
        snippet,
        skipped: false,
    })
}

pub fn write_snippet(path: &Path, content: &str) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| {
            format!(
                "failed to create manager init directory at {}",
                parent.display()
            )
        })?;
    }

    let mut temp = NamedTempFile::new_in(
        path.parent()
            .ok_or_else(|| anyhow!("manager init path must have a parent directory"))?,
    )?;
    temp.write_all(content.as_bytes())?;
    temp.flush()?;

    if path.exists() {
        fs::remove_file(path).ok();
    }

    temp.persist(path)?;
    Ok(())
}

pub fn telemetry_payload(states: &[ManagerState]) -> Value {
    Value::Array(
        states
            .iter()
            .map(|state| {
                json!({
                    "name": state.name,
                    "detected": state.detected,
                    "reason": state.reason,
                    "has_snippet": state
                        .snippet
                        .as_ref()
                        .map(|snippet| !snippet.trim().is_empty())
                        .unwrap_or(false),
                })
            })
            .collect(),
    )
}

fn evaluate_manager(spec: ManagerSpec, cfg: &ManagerInitConfig) -> ManagerState {
    let manager_name = spec.name.clone();
    let snippet = select_snippet(&spec, cfg.platform);
    let lower_name = manager_name.to_lowercase();

    if cfg.skip_list.contains(&lower_name) {
        if cfg.debug {
            debug!(
                target = "substrate::manager_init",
                manager = %manager_name,
                "skipping manager via SUBSTRATE_SKIP_MANAGER_INIT_LIST"
            );
        }
        return ManagerState {
            name: manager_name,
            detected: false,
            reason: Some("skipped via SUBSTRATE_SKIP_MANAGER_INIT_LIST".to_string()),
            snippet: None,
        };
    }

    let reason = detect_manager(&spec.detect, cfg);
    let detected = reason.is_some();

    if cfg.debug {
        debug!(
            target = "substrate::manager_init",
            manager = %manager_name,
            detected,
            reason = reason.as_deref().unwrap_or("<none>"),
            "manager detection evaluated"
        );
    }

    ManagerState {
        name: manager_name,
        detected,
        reason,
        snippet,
    }
}

fn detect_manager(detect: &DetectSpec, cfg: &ManagerInitConfig) -> Option<String> {
    if let Some(reason) = detect_files(&detect.files) {
        return Some(reason);
    }

    if let Some(reason) = detect_commands(&detect.commands) {
        return Some(reason);
    }

    if let Some(reason) = detect_env(&detect.env) {
        return Some(reason);
    }

    if let Some(script) = detect.script.as_deref() {
        match detect_script(script, cfg.platform) {
            Ok(result) => return result,
            Err(err) => {
                if cfg.debug {
                    debug!(
                        target = "substrate::manager_init",
                        error = %err,
                        "manager detect script failed"
                    );
                }
                return None;
            }
        }
    }

    None
}

fn detect_files(files: &[PathBuf]) -> Option<String> {
    for path in files {
        if path.exists() {
            return Some(format!("file:{}", path.display()));
        }
    }
    None
}

fn detect_commands(commands: &[String]) -> Option<String> {
    for command in commands {
        if which(command).is_ok() {
            return Some(format!("command:{}", command));
        }
    }
    None
}

fn detect_env(env_reqs: &std::collections::HashMap<String, String>) -> Option<String> {
    for (key, expected) in env_reqs {
        if let Ok(value) = env::var(key) {
            if expected.is_empty() || value == *expected {
                return Some(format!("env:{}", key));
            }
        }
    }
    None
}

fn detect_script(script: &str, platform: Platform) -> Result<Option<String>> {
    if script.trim().is_empty() {
        return Ok(None);
    }

    let success = run_detect_script(script, platform)
        .with_context(|| "failed to execute manager detect script")?;
    if success {
        Ok(Some("script".to_string()))
    } else {
        Ok(None)
    }
}

fn run_detect_script(script: &str, platform: Platform) -> Result<bool> {
    let mut cmd = if platform == Platform::Windows {
        let mut command = Command::new("powershell");
        command.arg("-NoProfile").arg("-Command").arg(script);
        command
    } else {
        let mut command = Command::new("sh");
        command.arg("-c").arg(script);
        command
    };

    let status = cmd.status()?;
    Ok(status.success())
}

fn select_snippet(spec: &ManagerSpec, platform: Platform) -> Option<String> {
    match platform {
        Platform::Windows => spec.init.powershell.clone(),
        Platform::Linux | Platform::MacOs => spec.init.shell.clone(),
    }
}

fn build_snippet(states: &[ManagerState]) -> String {
    let mut content = String::from(SNIPPET_HEADER);
    let mut appended = false;

    for state in states {
        if !state.detected {
            continue;
        }
        if let Some(snippet) = &state.snippet {
            let trimmed = snippet.trim();
            if trimmed.is_empty() {
                continue;
            }
            appended = true;
            content.push_str(&format!("\n# manager: {}\n{}\n", state.name, snippet));
        }
    }

    if !appended {
        content.push_str("\n# No managers detected\n");
    }

    content
}

fn is_truthy(value: &str) -> bool {
    matches!(
        value.to_ascii_lowercase().as_str(),
        "1" | "true" | "yes" | "on"
    )
}

fn parse_skip_list(raw: &str) -> HashSet<String> {
    raw.split(|c: char| c == ',' || c.is_whitespace())
        .map(|item| item.trim().to_lowercase())
        .filter(|item| !item.is_empty())
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use std::{
        collections::{HashMap, HashSet},
        env, fs,
    };
    use tempfile::{tempdir, TempDir};

    fn make_manifest(managers: &str) -> (ManifestPaths, TempDir) {
        let dir = tempdir().unwrap();
        let manifest_path = dir.path().join("manager_hooks.yaml");
        let payload = format!("version: 1\nmanagers:\n{}", managers);
        fs::write(&manifest_path, payload).unwrap();
        (
            ManifestPaths {
                base: manifest_path,
                overlay: None,
            },
            dir,
        )
    }

    fn base_config() -> ManagerInitConfig {
        ManagerInitConfig {
            skip_all: false,
            skip_list: HashSet::new(),
            platform: if cfg!(windows) {
                Platform::Windows
            } else if cfg!(target_os = "macos") {
                Platform::MacOs
            } else {
                Platform::Linux
            },
            debug: false,
        }
    }

    #[test]
    fn truthy_check_parses_common_values() {
        assert!(is_truthy("1"));
        assert!(is_truthy("true"));
        assert!(is_truthy("YES"));
        assert!(!is_truthy("0"));
        assert!(!is_truthy("nope"));
    }

    #[test]
    fn skip_list_parser_handles_commas_and_spaces() {
        let parsed = parse_skip_list("nvm, pyenv  ,direnv");
        assert!(parsed.contains("nvm"));
        assert!(parsed.contains("pyenv"));
        assert!(parsed.contains("direnv"));
    }

    #[test]
    fn detect_env_matches_expected_values() {
        let mut env_reqs = HashMap::new();
        env_reqs.insert("TEST_ENV_KEY".to_string(), "value".to_string());
        env::set_var("TEST_ENV_KEY", "value");
        assert_eq!(detect_env(&env_reqs), Some("env:TEST_ENV_KEY".to_string()));
        env::remove_var("TEST_ENV_KEY");
    }

    #[test]
    fn detect_files_returns_first_match() {
        let dir = tempdir().unwrap();
        let missing = dir.path().join("missing");
        let present = dir.path().join("present");
        fs::write(&present, "ok").unwrap();
        let reason = detect_files(&vec![missing, present.clone()]);
        assert_eq!(reason, Some(format!("file:{}", present.display())));
    }

    #[test]
    fn detect_commands_handles_absolute_paths() {
        let current = env::current_exe().unwrap();
        let reason = detect_commands(&[current.to_string_lossy().to_string()]);
        assert_eq!(reason, Some(format!("command:{}", current.display())));
    }

    #[cfg(not(windows))]
    #[test]
    fn detect_script_runs_shell_commands() {
        assert_eq!(
            detect_script("exit 0", Platform::Linux).unwrap(),
            Some("script".to_string())
        );
        assert_eq!(detect_script("exit 1", Platform::Linux).unwrap(), None);
    }

    #[cfg(windows)]
    #[test]
    fn detect_script_runs_powershell_commands() {
        assert_eq!(
            detect_script("exit 0", Platform::Windows).unwrap(),
            Some("script".to_string())
        );
        assert_eq!(detect_script("exit 1", Platform::Windows).unwrap(), None);
    }

    #[test]
    #[serial]
    fn config_from_env_respects_skip_and_debug_flags() {
        let prev_skip = env::var("SUBSTRATE_SKIP_MANAGER_INIT").ok();
        let prev_list = env::var("SUBSTRATE_SKIP_MANAGER_INIT_LIST").ok();
        let prev_debug = env::var("SUBSTRATE_MANAGER_INIT_DEBUG").ok();

        env::set_var("SUBSTRATE_SKIP_MANAGER_INIT", "YeS");
        env::set_var("SUBSTRATE_SKIP_MANAGER_INIT_LIST", "NVM, PyEnv");
        env::set_var("SUBSTRATE_MANAGER_INIT_DEBUG", "on");

        let cfg = ManagerInitConfig::from_env(Platform::Linux);
        assert!(cfg.skip_all);
        assert!(cfg.debug);
        assert!(cfg.skip_list.contains("nvm"));
        assert!(cfg.skip_list.contains("pyenv"));

        match prev_skip {
            Some(value) => env::set_var("SUBSTRATE_SKIP_MANAGER_INIT", value),
            None => env::remove_var("SUBSTRATE_SKIP_MANAGER_INIT"),
        }
        match prev_list {
            Some(value) => env::set_var("SUBSTRATE_SKIP_MANAGER_INIT_LIST", value),
            None => env::remove_var("SUBSTRATE_SKIP_MANAGER_INIT_LIST"),
        }
        match prev_debug {
            Some(value) => env::set_var("SUBSTRATE_MANAGER_INIT_DEBUG", value),
            None => env::remove_var("SUBSTRATE_MANAGER_INIT_DEBUG"),
        }
    }

    #[test]
    fn detect_and_generate_skips_all_when_flag_set() {
        let (paths, _tmp) = make_manifest(
            r#"
  - name: Sample
    priority: 10
    detect:
      files: ["/tmp/nonexistent"]
    init:
      shell: |
        export SAMPLE=1
"#,
        );

        let mut cfg = base_config();
        cfg.skip_all = true;

        let result = detect_and_generate(paths, cfg).unwrap();
        assert!(result.skipped);
        assert!(result.states.is_empty());
        assert!(result.snippet.contains("SUBSTRATE_SKIP_MANAGER_INIT"));
    }

    #[test]
    fn detect_and_generate_collects_detected_managers_and_snippet() {
        let temp = tempdir().unwrap();
        let file_path = temp.path().join("nvm.sh");
        fs::write(&file_path, "echo nvm").unwrap();
        let exe = env::current_exe().unwrap();
        let manifest_body = format!(
            r#"
  - name: FileMgr
    priority: 10
    detect:
      files: ["{}"]
    init:
      shell: |
        export FILE=1
  - name: CommandMgr
    priority: 20
    detect:
      commands: ["{}"]
    init:
      shell: |
        export CMD=1
"#,
            file_path.display(),
            exe.display()
        );
        let (paths, _tmp) = make_manifest(&manifest_body);

        let result = detect_and_generate(paths, base_config()).unwrap();
        assert_eq!(result.states.len(), 2);
        assert!(!result.skipped);
        let file_state = result
            .states
            .iter()
            .find(|state| state.name == "FileMgr")
            .unwrap();
        assert!(file_state.detected);
        assert!(file_state.reason.as_ref().unwrap().starts_with("file:"));
        let command_state = result
            .states
            .iter()
            .find(|state| state.name == "CommandMgr")
            .unwrap();
        assert!(command_state.detected);
        assert!(command_state
            .reason
            .as_ref()
            .unwrap()
            .starts_with("command:"));

        assert!(result.snippet.starts_with(SNIPPET_HEADER));
        let first_index = result.snippet.find("manager: FileMgr").unwrap();
        let second_index = result.snippet.find("manager: CommandMgr").unwrap();
        assert!(first_index < second_index);
    }

    #[test]
    fn detect_and_generate_respects_skip_list_entries() {
        let temp = tempdir().unwrap();
        let file_path = temp.path().join("skipme");
        fs::write(&file_path, "skip").unwrap();
        let manifest_body = format!(
            r#"
  - name: SkipMe
    priority: 5
    detect:
      files: ["{}"]
    init:
      shell: |
        export SKIP=1
"#,
            file_path.display()
        );
        let (paths, _tmp) = make_manifest(&manifest_body);

        let mut cfg = base_config();
        cfg.skip_list.insert("skipme".to_string());
        cfg.debug = true;

        let result = detect_and_generate(paths, cfg).unwrap();
        assert_eq!(result.states.len(), 1);
        let state = &result.states[0];
        assert!(!state.detected);
        assert_eq!(
            state.reason.as_deref(),
            Some("skipped via SUBSTRATE_SKIP_MANAGER_INIT_LIST")
        );
        assert!(state.snippet.is_none());
        assert!(result.snippet.contains("# No managers detected"));
    }
    #[test]
    fn write_snippet_creates_parent_dirs() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("subdir").join("manager_init.sh");
        let snippet = "# test";
        write_snippet(&path, snippet).unwrap();
        assert!(path.exists());
        let written = std::fs::read_to_string(path).unwrap();
        assert_eq!(written, snippet);
    }

    #[test]
    fn write_snippet_replaces_existing_content() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("manager_init.sh");
        write_snippet(&path, "first").unwrap();
        write_snippet(&path, "second").unwrap();
        let written = std::fs::read_to_string(path).unwrap();
        assert_eq!(written, "second");
    }

    #[test]
    fn telemetry_payload_marks_snippet_presence() {
        let states = vec![
            ManagerState {
                name: "nvm".into(),
                detected: true,
                reason: Some("file:/nvm".into()),
                snippet: Some("export NVM=1".into()),
            },
            ManagerState {
                name: "pyenv".into(),
                detected: false,
                reason: None,
                snippet: Some("".into()),
            },
            ManagerState {
                name: "direnv".into(),
                detected: false,
                reason: None,
                snippet: None,
            },
        ];
        let payload = telemetry_payload(&states);
        let array = payload.as_array().unwrap();
        assert_eq!(array.len(), 3);
        assert_eq!(array[0]["name"], "nvm");
        assert_eq!(array[0]["has_snippet"], true);
        assert_eq!(array[1]["has_snippet"], false);
        assert_eq!(array[2]["has_snippet"], false);
    }
}
