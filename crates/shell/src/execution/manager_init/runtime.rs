//! Manager detection and snippet generation.

use super::config::{ManagerInitConfig, ManifestPaths};
use anyhow::{anyhow, Context, Result};
use serde_json::{json, Value};
use std::env;
use std::ffi::{OsStr, OsString};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;
use tempfile::NamedTempFile;
use tracing::debug;
use which::which;

use substrate_common::manager_manifest::{DetectSpec, ManagerManifest, ManagerSpec, Platform};

pub(crate) const SNIPPET_HEADER: &str = "# Generated by Substrate â€“ do not edit\n";

#[derive(Debug, Clone)]
pub struct ManagerState {
    pub name: String,
    pub detected: bool,
    pub reason: Option<String>,
    pub snippet: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ManagerInitResult {
    pub states: Vec<ManagerState>,
    pub snippet: String,
    pub skipped: bool,
}

pub fn detect_and_generate(
    manifest_paths: ManifestPaths,
    cfg: ManagerInitConfig,
) -> Result<ManagerInitResult> {
    if cfg.skip_all {
        let snippet = format!(
            "{}# Manager init disabled via SUBSTRATE_SKIP_MANAGER_INIT\n",
            SNIPPET_HEADER
        );
        return Ok(ManagerInitResult {
            states: Vec::new(),
            snippet,
            skipped: true,
        });
    }

    let manifest = ManagerManifest::load(&manifest_paths.base, manifest_paths.overlay.as_deref())
        .with_context(|| {
        format!(
            "failed to load manager manifest at {}",
            manifest_paths.base.display()
        )
    })?;

    let specs = manifest.resolve_for_platform(cfg.platform);
    let mut states = Vec::with_capacity(specs.len());
    for spec in specs {
        states.push(evaluate_manager(spec, &cfg));
    }

    let snippet = build_snippet(&states);
    Ok(ManagerInitResult {
        states,
        snippet,
        skipped: false,
    })
}

pub fn write_snippet(path: &Path, content: &str) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| {
            format!(
                "failed to create manager init directory at {}",
                parent.display()
            )
        })?;
    }

    let mut temp = NamedTempFile::new_in(
        path.parent()
            .ok_or_else(|| anyhow!("manager init path must have a parent directory"))?,
    )?;
    temp.write_all(content.as_bytes())?;
    temp.flush()?;

    if path.exists() {
        fs::remove_file(path).ok();
    }

    temp.persist(path)?;
    Ok(())
}

pub fn telemetry_payload(states: &[ManagerState]) -> Value {
    Value::Array(
        states
            .iter()
            .map(|state| {
                json!({
                    "name": state.name,
                    "detected": state.detected,
                    "reason": state.reason,
                    "has_snippet": state
                        .snippet
                        .as_ref()
                        .map(|snippet| !snippet.trim().is_empty())
                        .unwrap_or(false),
                })
            })
            .collect(),
    )
}

fn evaluate_manager(spec: ManagerSpec, cfg: &ManagerInitConfig) -> ManagerState {
    let manager_name = spec.name.clone();
    let snippet = select_snippet(&spec, cfg.platform);
    let lower_name = manager_name.to_lowercase();

    if cfg.skip_list.contains(&lower_name) {
        if cfg.debug {
            debug!(
                target = "substrate::manager_init",
                manager = %manager_name,
                "skipping manager via SUBSTRATE_SKIP_MANAGER_INIT_LIST"
            );
        }
        return ManagerState {
            name: manager_name,
            detected: false,
            reason: Some("skipped via SUBSTRATE_SKIP_MANAGER_INIT_LIST".to_string()),
            snippet: None,
        };
    }

    let reason = detect_manager(&spec.detect, cfg);
    let detected = reason.is_some();

    if cfg.debug {
        debug!(
            target = "substrate::manager_init",
            manager = %manager_name,
            detected,
            reason = reason.as_deref().unwrap_or("<none>"),
            "manager detection evaluated"
        );
    }

    ManagerState {
        name: manager_name,
        detected,
        reason,
        snippet,
    }
}

fn detect_manager(detect: &DetectSpec, cfg: &ManagerInitConfig) -> Option<String> {
    if let Some(reason) = detect_files(&detect.files) {
        return Some(reason);
    }

    if let Some(reason) = detect_commands(&detect.commands) {
        return Some(reason);
    }

    if let Some(reason) = detect_env(&detect.env) {
        return Some(reason);
    }

    if let Some(script) = detect.script.as_deref() {
        match detect_script(script, cfg.platform) {
            Ok(result) => return result,
            Err(err) => {
                if cfg.debug {
                    debug!(
                        target = "substrate::manager_init",
                        error = %err,
                        "manager detect script failed"
                    );
                }
                return None;
            }
        }
    }

    None
}

pub(crate) fn detect_files(files: &[PathBuf]) -> Option<String> {
    for path in files {
        if path.exists() {
            return Some(format!("file:{}", path.display()));
        }
    }
    None
}

pub(crate) fn detect_commands(commands: &[String]) -> Option<String> {
    for command in commands {
        if which(command).is_ok() {
            return Some(format!("command:{}", command));
        }
    }
    None
}

pub(crate) fn detect_env(env_reqs: &std::collections::HashMap<String, String>) -> Option<String> {
    for (key, expected) in env_reqs {
        if let Ok(value) = env::var(key) {
            if expected.is_empty() || value == *expected {
                return Some(format!("env:{}", key));
            }
        }
    }
    None
}

pub(crate) fn detect_script(script: &str, platform: Platform) -> Result<Option<String>> {
    if script.trim().is_empty() {
        return Ok(None);
    }

    let success = run_detect_script(script, platform)
        .with_context(|| "failed to execute manager detect script")?;
    if success {
        Ok(Some("script".to_string()))
    } else {
        Ok(None)
    }
}

fn run_detect_script(script: &str, platform: Platform) -> Result<bool> {
    let mut cmd = match platform {
        Platform::Windows => {
            let mut command = Command::new("powershell");
            command.arg("-NoProfile").arg("-Command").arg(script);
            command
        }
        Platform::Linux | Platform::MacOs => {
            let shell = select_posix_shell();
            let mut command = Command::new(&shell);
            command.arg("-c").arg(script);
            command
        }
    };

    let status = cmd.status()?;
    Ok(status.success())
}

fn select_posix_shell() -> OsString {
    if let Some(shell) = env::var_os("SUBSTRATE_MANAGER_INIT_SHELL") {
        if !shell.as_os_str().is_empty() {
            return shell;
        }
    }
    if let Some(shell) = env::var_os("SHELL") {
        if path_is_absolute_and_exists(&shell) {
            return shell;
        }
    }
    for candidate in ["/bin/sh", "/usr/bin/sh", "/system/bin/sh"] {
        let path = Path::new(candidate);
        if path.exists() {
            return OsString::from(candidate);
        }
    }
    OsString::from("sh")
}

fn path_is_absolute_and_exists(value: &OsStr) -> bool {
    let path = Path::new(value);
    path.is_absolute() && path.exists()
}

fn select_snippet(spec: &ManagerSpec, platform: Platform) -> Option<String> {
    match platform {
        Platform::Windows => spec
            .init
            .powershell
            .clone()
            .or_else(|| spec.init.shell.clone()),
        Platform::Linux | Platform::MacOs => spec.init.shell.clone(),
    }
}

fn build_snippet(states: &[ManagerState]) -> String {
    let mut content = String::from(SNIPPET_HEADER);
    let mut appended = false;

    for state in states {
        if !state.detected {
            continue;
        }
        if let Some(snippet) = &state.snippet {
            let trimmed = snippet.trim();
            if trimmed.is_empty() {
                continue;
            }
            appended = true;
            content.push_str(&format!("\n# manager: {}\n{}\n", state.name, snippet));
        }
    }

    if !appended {
        content.push_str("\n# No managers detected\n");
    }

    content
}
