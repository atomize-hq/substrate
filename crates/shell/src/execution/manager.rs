use super::manager_init;
use super::ShellConfig;
use anyhow::Result;
use chrono::Utc;
use serde_json::json;
use std::{
    env,
    ffi::OsStr,
    fs,
    path::{Path, PathBuf},
    process::Command,
};
use substrate_common::{log_schema, Platform};
use substrate_trace::append_to_trace;
use tracing::warn;

pub(crate) fn configure_manager_init(
    config: &ShellConfig,
) -> Option<manager_init::ManagerInitResult> {
    let overlay = config
        .manager_init_path
        .parent()
        .map(|dir| dir.join("manager_hooks.local.yaml"));

    let manifest_paths = manager_init::ManifestPaths {
        base: manager_manifest_base_path(),
        overlay,
    };

    let init_cfg = manager_init::ManagerInitConfig::from_env(current_platform());

    match manager_init::detect_and_generate(manifest_paths, init_cfg) {
        Ok(result) => {
            if cfg!(test) {
                eprintln!("configure_manager_init snippet:\n{}", result.snippet);
            }
            if let Err(err) =
                manager_init::write_snippet(&config.manager_init_path, &result.snippet)
            {
                warn!(
                    target = "substrate::shell",
                    error = %err,
                    "failed to write manager init snippet"
                );
                let _ = log_manager_init_error(config, &format!("write_failed: {}", err));
                None
            } else {
                env::set_var("SUBSTRATE_MANAGER_INIT", &config.manager_init_path);
                Some(result)
            }
        }
        Err(err) => {
            warn!(
                target = "substrate::shell",
                error = %err,
                "manager init generation failed"
            );
            let placeholder = format!(
                "# Generated by Substrate – do not edit\n# manager init unavailable: {}\n",
                err
            );
            if let Err(write_err) =
                manager_init::write_snippet(&config.manager_init_path, &placeholder)
            {
                warn!(
                    target = "substrate::shell",
                    error = %write_err,
                    "failed to write placeholder manager init snippet"
                );
            }
            env::set_var("SUBSTRATE_MANAGER_INIT", &config.manager_init_path);
            let _ = log_manager_init_error(config, &err.to_string());
            None
        }
    }
}

pub(crate) fn manager_manifest_base_path() -> PathBuf {
    if let Ok(override_path) = env::var("SUBSTRATE_MANAGER_MANIFEST") {
        return PathBuf::from(override_path);
    }

    if let Some(path) = installed_manager_manifest_base_path() {
        return canonicalize_or(&path);
    }

    let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    crate_dir
        .parent()
        .and_then(|dir| dir.parent())
        .map(|root| root.join("config").join("manager_hooks.yaml"))
        .unwrap_or_else(|| PathBuf::from("config/manager_hooks.yaml"))
}

fn canonicalize_or(path: &Path) -> PathBuf {
    fs::canonicalize(path).unwrap_or_else(|_| path.to_path_buf())
}

fn installed_manager_manifest_base_path() -> Option<PathBuf> {
    let exe_path = env::current_exe().ok()?;
    let canonical = canonicalize_or(&exe_path);

    let bin_dir = canonical.parent()?;
    if bin_dir.file_name() != Some(OsStr::new("bin")) {
        return None;
    }

    let version_dir = bin_dir.parent()?;
    let versions_dir = version_dir.parent()?;
    if versions_dir.file_name() != Some(OsStr::new("versions")) {
        return None;
    }

    Some(version_dir.join("config").join("manager_hooks.yaml"))
}

pub(crate) fn current_platform() -> Platform {
    if cfg!(target_os = "macos") {
        Platform::MacOs
    } else if cfg!(windows) {
        Platform::Windows
    } else {
        Platform::Linux
    }
}

pub(crate) fn log_manager_init_event(
    config: &ShellConfig,
    result: &manager_init::ManagerInitResult,
) -> Result<()> {
    let entry = json!({
        log_schema::TIMESTAMP: Utc::now().to_rfc3339(),
        log_schema::EVENT_TYPE: "manager_init",
        log_schema::SESSION_ID: config.session_id,
        log_schema::COMPONENT: "shell",
        "snippet_path": config.manager_init_path.display().to_string(),
        "skipped": result.skipped,
        "states": manager_init::telemetry_payload(&result.states),
    });
    append_to_trace(&entry)?;
    Ok(())
}

pub(crate) fn log_manager_init_error(config: &ShellConfig, error: &str) -> Result<()> {
    let entry = json!({
        log_schema::TIMESTAMP: Utc::now().to_rfc3339(),
        log_schema::EVENT_TYPE: "manager_init",
        log_schema::SESSION_ID: config.session_id,
        log_schema::COMPONENT: "shell",
        "snippet_path": config.manager_init_path.display().to_string(),
        "error": error,
    });
    append_to_trace(&entry)?;
    Ok(())
}

static MANAGER_ENV_SCRIPT: &str = r#"#!/usr/bin/env bash
# Generated by Substrate – do not edit
if [[ -n "${SUBSTRATE_MANAGER_ENV_ACTIVE:-}" ]]; then
    return 0
fi
export SUBSTRATE_MANAGER_ENV_ACTIVE=1

substrate_manager_init="${SUBSTRATE_MANAGER_INIT:-}"
if [[ -n "$substrate_manager_init" && -f "$substrate_manager_init" ]]; then
    # shellcheck disable=SC1090
    source "$substrate_manager_init"
fi

substrate_original="${SUBSTRATE_ORIGINAL_BASH_ENV:-}"
if [[ -n "$substrate_original" && -f "$substrate_original" ]]; then
    # shellcheck disable=SC1090
    source "$substrate_original"
fi

legacy_bashenv="${HOME}/.substrate_bashenv"
if [[ -f "$legacy_bashenv" ]]; then
    # shellcheck disable=SC1090
    source "$legacy_bashenv"
fi
"#;

pub(crate) fn write_manager_env_script_at(path: &Path) -> Result<()> {
    manager_init::write_snippet(path, MANAGER_ENV_SCRIPT)
}

pub(crate) fn write_manager_env_script(config: &ShellConfig) -> Result<()> {
    write_manager_env_script_at(&config.manager_env_path)
}

pub(crate) trait CommandEnvAdapter {
    fn set_env_var(&mut self, key: &str, value: &str);
    fn remove_env_var(&mut self, key: &str);
}

impl CommandEnvAdapter for Command {
    fn set_env_var(&mut self, key: &str, value: &str) {
        self.env(key, value);
    }

    fn remove_env_var(&mut self, key: &str) {
        self.env_remove(key);
    }
}

impl CommandEnvAdapter for portable_pty::CommandBuilder {
    fn set_env_var(&mut self, key: &str, value: &str) {
        self.env(key, value);
    }

    fn remove_env_var(&mut self, key: &str) {
        self.env_remove(key);
    }
}

pub(crate) fn configure_child_shell_env<E: CommandEnvAdapter>(
    cmd: &mut E,
    config: &ShellConfig,
    is_bash: bool,
    enable_preexec: bool,
) {
    if config.no_world {
        return;
    }

    if let Some(path) = config.shimmed_path.as_deref() {
        cmd.set_env_var("PATH", path);
    }

    if let Some(original) = &config.host_bash_env {
        cmd.set_env_var("SUBSTRATE_ORIGINAL_BASH_ENV", original);
    } else {
        cmd.remove_env_var("SUBSTRATE_ORIGINAL_BASH_ENV");
    }

    if !is_bash {
        cmd.remove_env_var("SUBSTRATE_ENABLE_PREEXEC");
        return;
    }

    let bash_env_path = if config.preexec_available {
        Some(config.bash_preexec_path.as_path())
    } else {
        Some(config.manager_env_path.as_path())
    };

    if let Some(path) = bash_env_path {
        let path_str = path.display().to_string();
        cmd.set_env_var("BASH_ENV", &path_str);
        if config.preexec_available && enable_preexec {
            cmd.set_env_var("SUBSTRATE_ENABLE_PREEXEC", "1");
        } else {
            cmd.remove_env_var("SUBSTRATE_ENABLE_PREEXEC");
        }
    } else {
        cmd.remove_env_var("BASH_ENV");
        cmd.remove_env_var("SUBSTRATE_ENABLE_PREEXEC");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::execution::settings::WorldRootSettings;
    use crate::execution::ShellMode;
    use serial_test::serial;
    use std::collections::HashMap;
    use std::fs;
    use substrate_common::WorldRootMode;
    use substrate_trace::init_trace;
    use tempfile::{tempdir, TempDir};
    use uuid::Uuid;

    fn test_shell_config(temp: &TempDir) -> ShellConfig {
        let trace_log_file = temp.path().join("trace.jsonl");
        env::set_var("SHIM_TRACE_LOG", &trace_log_file);
        let _ = substrate_trace::set_global_trace_context(substrate_trace::TraceContext::default());
        let _ = init_trace(Some(trace_log_file.clone()));

        ShellConfig {
            mode: ShellMode::Interactive { use_pty: false },
            session_id: Uuid::now_v7().to_string(),
            trace_log_file,
            original_path: env::var("PATH").unwrap_or_default(),
            shim_dir: temp.path().join("shims"),
            shell_path: if cfg!(windows) {
                "cmd.exe".to_string()
            } else {
                "/bin/sh".to_string()
            },
            ci_mode: false,
            no_exit_on_error: false,
            skip_shims: false,
            no_world: false,
            world_root: WorldRootSettings {
                mode: WorldRootMode::Project,
                path: temp.path().to_path_buf(),
                caged: true,
            },
            async_repl: false,
            env_vars: HashMap::new(),
            manager_init_path: temp.path().join("manager_init.sh"),
            manager_env_path: temp.path().join("manager_env.sh"),
            shimmed_path: Some(temp.path().join("shims").display().to_string()),
            host_bash_env: None,
            bash_preexec_path: temp.path().join(".substrate_preexec"),
            preexec_available: true,
        }
    }

    fn write_manifest(temp: &TempDir, name: &str, contents: &str) -> PathBuf {
        let path = temp.path().join(name);
        fs::write(&path, contents).unwrap();
        path
    }

    fn set_env(key: &str, value: &str) -> Option<String> {
        let previous = env::var(key).ok();
        env::set_var(key, value);
        previous
    }

    fn restore_env(key: &str, previous: Option<String>) {
        if let Some(value) = previous {
            env::set_var(key, value);
        } else {
            env::remove_var(key);
        }
    }

    #[test]
    #[serial]
    fn configure_manager_init_generates_snippet_and_exports_env() {
        let temp = tempdir().unwrap();
        let detect_path = temp.path().join("detect-me");
        fs::write(&detect_path, "detect").unwrap();
        let manifest_contents = format!(
            "version: 1\nmanagers:\n  - name: Demo\n    priority: 5\n    detect:\n      files: ['{}']\n    init:\n      shell: |\n        export DEMO=1\n",
            detect_path.display()
        );
        let manifest_path = write_manifest(&temp, "manager_hooks.yaml", &manifest_contents);
        let previous_manifest = set_env(
            "SUBSTRATE_MANAGER_MANIFEST",
            &manifest_path.display().to_string(),
        );
        let previous_init = env::var("SUBSTRATE_MANAGER_INIT").ok();

        let config = test_shell_config(&temp);
        let result = configure_manager_init(&config).expect("manager init result");
        assert_eq!(result.states.len(), 1);
        assert!(result.states[0].detected);
        let snippet = fs::read_to_string(&config.manager_init_path).unwrap();
        assert!(snippet.contains("# manager: Demo"));
        assert!(snippet.contains("export DEMO=1"));
        assert_eq!(
            env::var("SUBSTRATE_MANAGER_INIT").unwrap(),
            config.manager_init_path.display().to_string()
        );

        restore_env("SUBSTRATE_MANAGER_MANIFEST", previous_manifest);
        restore_env("SUBSTRATE_MANAGER_INIT", previous_init);
    }

    #[test]
    #[serial]
    fn configure_manager_init_honors_overlay_file() {
        let temp = tempdir().unwrap();
        let manifest_contents = format!(
            "version: 1\nmanagers:\n  - name: Demo\n    detect:\n      files: ['{}']\n    init:\n      shell: |\n        export BASE=1\n",
            temp.path().join("missing").display()
        );
        let manifest_path = write_manifest(&temp, "manager_hooks.yaml", &manifest_contents);
        let overlay_path = temp.path().join("manager_hooks.local.yaml");
        let overlay_contents = r#"version: 1
managers:
  - name: Demo
    detect:
      script: "exit 0"
    init:
      shell: |
        export OVERLAY=1
"#;
        fs::write(&overlay_path, overlay_contents).unwrap();

        let previous_manifest = set_env(
            "SUBSTRATE_MANAGER_MANIFEST",
            &manifest_path.display().to_string(),
        );
        let previous_init = env::var("SUBSTRATE_MANAGER_INIT").ok();

        let config = test_shell_config(&temp);
        let result = configure_manager_init(&config).expect("overlay manager init result");
        assert_eq!(result.states[0].reason.as_deref(), Some("script"));
        let snippet = fs::read_to_string(&config.manager_init_path).unwrap();
        assert!(snippet.contains("OVERLAY=1"));

        restore_env("SUBSTRATE_MANAGER_MANIFEST", previous_manifest);
        restore_env("SUBSTRATE_MANAGER_INIT", previous_init);
    }

    #[test]
    #[serial]
    fn manager_env_script_sources_manager_and_legacy_snippets() {
        let temp = tempdir().unwrap();
        let config = test_shell_config(&temp);
        write_manager_env_script(&config).expect("write manager env");
        let script = fs::read_to_string(&config.manager_env_path).unwrap();
        assert!(script.contains("SUBSTRATE_MANAGER_INIT"));
        assert!(script.contains("SUBSTRATE_ORIGINAL_BASH_ENV"));
        assert!(script.contains(".substrate_bashenv"));
    }

    #[test]
    #[serial]
    fn manager_manifest_base_path_prefers_env_override() {
        let temp = tempdir().unwrap();
        let override_path = temp.path().join("custom.yaml");
        let previous = set_env(
            "SUBSTRATE_MANAGER_MANIFEST",
            &override_path.display().to_string(),
        );
        let resolved = manager_manifest_base_path();
        assert_eq!(resolved, override_path);
        restore_env("SUBSTRATE_MANAGER_MANIFEST", previous);
    }
}
