#![cfg(unix)]

mod support;

use std::fs;
use std::os::unix::fs::PermissionsExt;
use support::{
    dedupe_path, path_str, payload_lines, substrate_command_for_home, ShellEnvFixture,
    PAYLOAD_MARKER,
};

#[test]
fn shell_env_injects_manager_snippets() {
    let fixture = ShellEnvFixture::new();
    let manifest = fixture.write_manifest(
        r#"version: 1
managers:
  - name: DemoManager
    detect:
      script: "exit 0"
    init:
      shell: |
        export MANAGER_MARKER="manager_init_loaded"
  - name: Volta
    detect:
      script: "exit 0"
    init:
      shell: |
        export VOLTA_MARKER="volta_loaded"
"#,
    );
    let host_bash_env = fixture.home().join("host_bash_env.sh");
    fs::write(&host_bash_env, "export HOST_BE_VALUE=\"host_env\"\n").unwrap();
    let legacy_bashenv = fixture.home().join(".substrate_bashenv");
    fs::write(&legacy_bashenv, "export LEGACY_MARKER=\"legacy_env\"\n").unwrap();
    let host_path = fixture.home().join("host-bin");
    fs::create_dir_all(&host_path).unwrap();
    let host_segment = path_str(&host_path);
    let host_path_str = format!("{host_segment}:/usr/bin:/bin");

    let manager_env_path = fixture.manager_env_path();
    let substrate_home = manager_env_path
        .parent()
        .expect("manager_env_path should have parent directory");
    let env_sh_path = substrate_home.join("env.sh");
    fs::write(
        &env_sh_path,
        "#!/usr/bin/env bash\nexport ENVSH_MARKER=\"envsh_loaded\"\n",
    )
    .unwrap();
    let mut env_perms = fs::metadata(&env_sh_path).unwrap().permissions();
    env_perms.set_mode(0o444);
    fs::set_permissions(&env_sh_path, env_perms).unwrap();
    let expected_env_sh = fs::read_to_string(&env_sh_path).unwrap();

    fs::write(&manager_env_path, "# stale manager env\n").unwrap();

    let legacy_manager_env = fixture.home().join("legacy_manager_env.sh");

    let script = format!(
        "printf '%s\\n' \"{marker}\" \"$PATH\" \"${{MANAGER_MARKER:-missing_manager}}\" \"$LEGACY_MARKER\" \
         \"$HOST_BE_VALUE\" \"${{ENVSH_MARKER:-missing}}\" \"${{BASH_ENV:-}}\" \
         \"${{SUBSTRATE_MANAGER_ENV:-none}}\" \"${{SUBSTRATE_ORIGINAL_BASH_ENV:-none}}\"",
        marker = PAYLOAD_MARKER
    );
    let output = substrate_command_for_home(&fixture)
        .env("PATH", &host_path_str)
        .env("BASH_ENV", &host_bash_env)
        // Ensure we don't accidentally route the command through a host-installed world-agent
        // (e.g., /run/substrate.sock) which would bypass host-side env injection.
        .env(
            "SUBSTRATE_WORLD_SOCKET",
            fixture.home().join("missing-world.sock"),
        )
        .env_remove("SUBSTRATE_SKIP_MANAGER_INIT")
        .env_remove("SUBSTRATE_SKIP_MANAGER_INIT_LIST")
        .env("SUBSTRATE_SHIM_PATH", path_str(&fixture.shim_dir()))
        .env("SUBSTRATE_SOCKET_ACTIVATION_OVERRIDE", "manual")
        .env("SUBSTRATE_MANAGER_ENV", path_str(&legacy_manager_env))
        .env("SUBSTRATE_MANAGER_MANIFEST", path_str(&manifest))
        .arg("-c")
        .arg(script)
        .output()
        .expect("failed to run substrate -c for shell env test");

    assert!(
        output.status.success(),
        "substrate -c failed: stdout={} stderr={}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );

    let lines = payload_lines(&output.stdout);
    assert_eq!(
        lines.len(),
        8,
        "unexpected payload: {}",
        String::from_utf8_lossy(&output.stdout)
    );
    let path_line = &lines[0];
    let shim_prefix = format!("{}:", fixture.shim_dir().display());
    assert!(
        path_line.starts_with(&shim_prefix),
        "PATH did not start with shims: {}",
        path_line
    );
    let remainder = &path_line[shim_prefix.len()..];
    assert_eq!(remainder, dedupe_path(&host_path_str));
    assert_eq!(lines[1], "manager_init_loaded");
    assert_eq!(lines[2], "legacy_env");
    assert_eq!(lines[3], "host_env");
    assert_eq!(lines[4], "envsh_loaded");
    assert_eq!(lines[5], fixture.preexec_path().display().to_string());
    assert_eq!(
        lines[6], "none",
        "legacy SUBSTRATE_MANAGER_ENV should be removed inside runtime shell env"
    );
    assert_eq!(lines[7], host_bash_env.display().to_string());

    assert!(
        !legacy_manager_env.exists(),
        "legacy SUBSTRATE_MANAGER_ENV path should not be written"
    );

    let manager_env_contents = fs::read_to_string(&manager_env_path).expect("manager env contents");
    assert!(
        manager_env_contents.contains("# Generated by Substrate"),
        "manager_env should be regenerated on startup"
    );
    assert!(
        manager_env_contents.contains("/env.sh"),
        "manager_env missing env.sh sourcing: {manager_env_contents}"
    );
    assert!(
        manager_env_contents.contains("manager_init.sh"),
        "manager_env missing manager_init.sh sourcing"
    );
    assert!(
        manager_env_contents.contains("SUBSTRATE_ORIGINAL_BASH_ENV"),
        "manager_env missing original BASH_ENV sourcing"
    );
    assert!(
        manager_env_contents.contains(".substrate_bashenv"),
        "manager_env missing legacy bashenv sourcing"
    );
    let manager_init_contents =
        fs::read_to_string(fixture.manager_init_path()).expect("manager init contents");
    assert!(
        manager_init_contents.contains("VOLTA_MARKER"),
        "manager init snippet missing Tier-2 manager content"
    );

    let env_sh_after = fs::read_to_string(&env_sh_path).unwrap();
    assert_eq!(
        env_sh_after, expected_env_sh,
        "runtime substrate execution must not rewrite env.sh"
    );
}

#[test]
fn shell_env_no_world_skips_manager_env() {
    let fixture = ShellEnvFixture::new();
    let host_path = fixture.home().join("host-only");
    fs::create_dir_all(&host_path).unwrap();
    let host_path_str = path_str(&host_path);
    let host_bash_env = fixture.home().join("host_env.sh");
    fs::write(&host_bash_env, "export HOST_ONLY=1\n").unwrap();

    let script = format!(
        "printf '%s\\n' \"{marker}\" \"$PATH\" \"${{BASH_ENV:-}}\" \
         \"${{SUBSTRATE_MANAGER_ENV:-none}}\" \"${{SUBSTRATE_MANAGER_INIT:-none}}\" \
         \"${{SUBSTRATE_ORIGINAL_BASH_ENV:-none}}\"",
        marker = PAYLOAD_MARKER
    );
    let output = substrate_command_for_home(&fixture)
        .env("PATH", &host_path_str)
        .env("BASH_ENV", &host_bash_env)
        .arg("--no-world")
        .arg("-c")
        .arg(script)
        .output()
        .expect("failed to run substrate --no-world");

    assert!(
        output.status.success(),
        "substrate --no-world failed: stdout={} stderr={}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );

    let lines = payload_lines(&output.stdout);
    assert_eq!(
        lines.len(),
        5,
        "unexpected payload: {}",
        String::from_utf8_lossy(&output.stdout)
    );
    assert_eq!(lines[0], host_path_str);
    assert_eq!(lines[1], host_bash_env.display().to_string());
    assert_eq!(lines[2], "none");
    assert_eq!(lines[3], "none");
    assert_eq!(lines[4], "none");
}

#[test]
fn shell_env_applies_overlay_manifest() {
    let fixture = ShellEnvFixture::new();
    let script = format!(
        "source \"{manager_env}\"; printf '%s\\n' \"{marker}\" \"$OVERLAY_VALUE\"",
        marker = PAYLOAD_MARKER,
        manager_env = fixture.manager_env_path().display()
    );
    let output = substrate_command_for_home(&fixture)
        .env_remove("SUBSTRATE_WORLD")
        .env_remove("SUBSTRATE_WORLD_ENABLED")
        .env(
            "SUBSTRATE_WORLD_SOCKET",
            fixture.home().join("missing-world.sock"),
        )
        .env("SUBSTRATE_SHIM_PATH", path_str(&fixture.shim_dir()))
        .env("SUBSTRATE_SOCKET_ACTIVATION_OVERRIDE", "manual")
        .env("OVERLAY_VALUE", "overlay-active")
        .env("SUBSTRATE_WORLD", "enabled")
        .env("SUBSTRATE_WORLD_ENABLED", "1")
        .arg("-c")
        .arg(script)
        .output()
        .expect("failed to run substrate for overlay manifest");
    assert!(
        output.status.success(),
        "substrate -c failed: stdout={} stderr={}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );
    let lines = payload_lines(&output.stdout);
    assert_eq!(
        lines.len(),
        1,
        "unexpected payload: {}",
        String::from_utf8_lossy(&output.stdout)
    );
    assert_eq!(lines[0], "overlay-active");
}
