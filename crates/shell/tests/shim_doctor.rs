#![cfg(unix)]

use assert_cmd::Command;
use serde_json::{json, Value};
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::sync::OnceLock;
use tempfile::{Builder, TempDir};

/// Ensure we reuse the already-built substrate binary across tests.
fn substrate_binary() -> Command {
    ensure_substrate_built();

    let mut cmd = Command::new(binary_path());
    cmd.env("TMPDIR", shared_tmpdir());
    cmd.env("SUBSTRATE_WORLD", "disabled");
    cmd
}

fn ensure_substrate_built() {
    static BUILD_ONCE: OnceLock<()> = OnceLock::new();
    BUILD_ONCE.get_or_init(|| {
        let status = std::process::Command::new("cargo")
            .args(["build", "-p", "substrate"])
            .status()
            .expect("failed to invoke cargo build -p substrate");
        assert!(status.success(), "cargo build -p substrate failed");
    });
}

fn binary_path() -> String {
    let binary_name = if cfg!(windows) {
        "substrate.exe"
    } else {
        "substrate"
    };

    if let Ok(workspace_dir) = std::env::var("CARGO_WORKSPACE_DIR") {
        format!("{workspace_dir}/target/debug/{binary_name}")
    } else {
        format!("../../target/debug/{binary_name}")
    }
}

fn shared_tmpdir() -> &'static Path {
    static TMP: OnceLock<PathBuf> = OnceLock::new();
    TMP.get_or_init(|| {
        let base = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../target/tests-tmp");
        std::fs::create_dir_all(&base).expect("failed to create shared TMPDIR");
        std::env::set_var("TMPDIR", &base);
        base
    })
}

fn new_temp_dir() -> TempDir {
    let base = shared_tmpdir();
    Builder::new()
        .prefix("substrate-doctor-")
        .tempdir_in(base)
        .expect("failed to create doctor test temp dir")
}

struct DoctorFixture {
    _temp: TempDir,
    home: PathBuf,
    manifest: PathBuf,
    trace: PathBuf,
    shim_dir: PathBuf,
}

impl DoctorFixture {
    fn new(manifest_contents: &str) -> Self {
        let temp = new_temp_dir();
        let home = temp.path().join("home");
        let shim_dir = home.join(".substrate/shims");
        fs::create_dir_all(&shim_dir).expect("failed to prepare shim directory");
        let trace = home.join(".substrate/trace.jsonl");
        fs::create_dir_all(trace.parent().unwrap()).expect("failed to create trace dir");
        fs::write(&trace, "").expect("failed to create trace log placeholder");
        let manager_init = home.join(".substrate/manager_init.sh");
        fs::write(&manager_init, "# Generated by shim doctor tests\n")
            .expect("failed to seed manager init file");
        let manifest = home.join("manager_hooks.yaml");
        fs::write(&manifest, manifest_contents).expect("failed to write manifest");
        Self {
            _temp: temp,
            home,
            manifest,
            trace,
            shim_dir,
        }
    }

    fn command(&self) -> Command {
        let mut cmd = substrate_binary();
        cmd.env("HOME", &self.home)
            .env("USERPROFILE", &self.home)
            .env("SUBSTRATE_MANAGER_MANIFEST", &self.manifest)
            .env("SHIM_TRACE_LOG", &self.trace);
        cmd
    }

    fn home(&self) -> &Path {
        &self.home
    }

    fn shim_dir(&self) -> &Path {
        &self.shim_dir
    }

    fn bashenv_path(&self) -> PathBuf {
        self.home.join(".substrate_bashenv")
    }

    fn write_hint_event(&self, name: &str, hint: &str, ts: &str) {
        let event = json!({
            "ts": ts,
            "event_type": "command_complete",
            "component": "shim",
            "manager_hint": {
                "name": name,
                "hint": hint,
                "pattern": ".*",
                "ts": ts,
            }
        });
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.trace)
            .expect("failed to open trace log for append");
        writeln!(file, "{}", event.to_string()).expect("failed to write hint event");
    }
}

#[test]
fn shim_doctor_human_mode_reports_status_and_path_diagnostics() {
    let manifest = r#"version: 1
managers:
  - name: DetectedManager
    priority: 10
    detect:
      script: "exit 0"
    init:
      shell: |
        export DETECTED_MARKER=1
    repair_hint: |
      export DETECTED_MARKER=1
  - name: MissingManager
    priority: 5
    detect:
      files:
        - "/nonexistent/path"
    init:
      shell: |
        export MISSING_MARKER=1
    repair_hint: |
      export MISSING_MARKER=1
"#;
    let fixture = DoctorFixture::new(manifest);
    fixture.write_hint_event(
        "MissingManager",
        "source ~/.substrate_bashenv so MissingManager loads",
        "2025-11-16T00:00:00Z",
    );

    let host_bin = fixture.home().join("host-bin");
    fs::create_dir_all(&host_bin).unwrap();
    let shim_path = fixture.shim_dir().display().to_string();
    let path_value = format!("{}:{}", shim_path, host_bin.display());

    let output = fixture
        .command()
        .env("PATH", &path_value)
        .arg("shim")
        .arg("doctor")
        .output()
        .expect("failed to execute shim doctor");

    assert!(
        output.status.success(),
        "expected shim doctor to succeed:\nstdout: {}\nstderr: {}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(
        stdout.contains("DetectedManager") && stdout.contains("MissingManager"),
        "doctor output should list both managers: {stdout}"
    );
    assert!(
        stdout.contains("Host PATH includes Substrate shims: yes"),
        "doctor output should report host PATH shims state: {stdout}"
    );
    assert!(
        stdout.contains(&shim_path),
        "doctor output should mention shim directory {shim_path}: {stdout}"
    );
    assert!(
        stdout.contains("MissingManager") && stdout.contains("source ~/.substrate_bashenv"),
        "doctor output should surface the latest repair hint: {stdout}"
    );
}

#[test]
fn shim_doctor_json_mode_surfaces_states_hints_and_path_details() {
    let missing_file = "/nonexistent/path/for/json-test";
    let manifest = format!(
        r#"version: 1
managers:
  - name: JsonDetected
    priority: 1
    detect:
      script: "exit 0"
    init:
      shell: |
        export JSON_DETECTED=1
    repair_hint: |
      export JSON_DETECTED=1
  - name: JsonMissing
    priority: 2
    detect:
      files:
        - "{missing_file}"
    init:
      shell: |
        export JSON_MISSING=1
    repair_hint: |
      export JSON_MISSING=1
"#
    );
    let fixture = DoctorFixture::new(&manifest);
    fixture.write_hint_event(
        "JsonMissing",
        "install JsonMissing locally",
        "2025-11-16T00:00:01Z",
    );
    fixture.write_hint_event(
        "JsonMissing",
        "install JsonMissing locally",
        "2025-11-17T00:00:01Z",
    );

    let host_path = fixture.home().join("bin");
    fs::create_dir_all(&host_path).unwrap();
    let output = fixture
        .command()
        .env("PATH", host_path.display().to_string())
        .arg("shim")
        .arg("doctor")
        .arg("--json")
        .output()
        .expect("failed to execute shim doctor --json");

    assert!(
        output.status.success(),
        "expected shim doctor --json to succeed:\nstdout: {}\nstderr: {}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );

    let report: Value =
        serde_json::from_slice(&output.stdout).expect("doctor output should be valid JSON");
    let states = report
        .get("states")
        .and_then(Value::as_array)
        .expect("states array missing from report");
    let detected = states
        .iter()
        .find(|value| value.get("name").and_then(Value::as_str) == Some("JsonDetected"))
        .expect("JsonDetected state missing");
    assert_eq!(
        detected.get("detected").and_then(Value::as_bool),
        Some(true)
    );
    assert_eq!(
        detected.get("reason").and_then(Value::as_str),
        Some("script")
    );
    assert!(
        detected
            .get("snippet")
            .and_then(Value::as_str)
            .map(|snippet| snippet.contains("JSON_DETECTED=1"))
            .unwrap_or(false),
        "detected snippet missing from JSON payload: {detected:?}"
    );
    let missing = states
        .iter()
        .find(|value| value.get("name").and_then(Value::as_str) == Some("JsonMissing"))
        .expect("JsonMissing state missing");
    assert_eq!(
        missing.get("detected").and_then(Value::as_bool),
        Some(false)
    );
    assert!(
        missing.get("reason").is_none() || missing.get("reason") == Some(&Value::Null),
        "missing manager should not have a detection reason: {missing:?}"
    );

    let hints = report
        .get("hints")
        .and_then(Value::as_array)
        .expect("hints array missing from report");
    assert_eq!(hints.len(), 1, "doctor should collapse duplicate hints");
    let hint = &hints[0];
    assert_eq!(
        hint.get("name").and_then(Value::as_str),
        Some("JsonMissing")
    );
    assert_eq!(
        hint.get("hint").and_then(Value::as_str),
        Some("install JsonMissing locally")
    );
    assert!(
        hint.get("last_seen")
            .and_then(Value::as_str)
            .map(|ts| ts.contains("2025-11-17"))
            .unwrap_or(false),
        "last_seen timestamp should reflect the newest log entry: {hint:?}"
    );

    let path = report
        .get("path")
        .and_then(Value::as_object)
        .expect("path diagnostics missing from report");
    assert_eq!(
        path.get("host_contains_shims").and_then(Value::as_bool),
        Some(false),
        "json path diagnostics should note that host PATH omits the shim dir"
    );
    let expected_shim_dir = fixture.shim_dir().display().to_string();
    assert_eq!(
        path.get("shim_dir").and_then(Value::as_str),
        Some(expected_shim_dir.as_str()),
        "json path diagnostics should point at the expected shim directory"
    );
}

#[test]
fn shim_doctor_repair_appends_snippet_and_creates_backup_files() {
    let manifest = r#"version: 1
managers:
  - name: RepairManager
    priority: 1
    detect:
      script: "exit 0"
    init:
      shell: |
        export REPAIR_MANAGER=1
    repair_hint: |
      # Substrate repair for RepairManager
      export REPAIR_MANAGER=1
      [ -s "$HOME/.repair-manager/init.sh" ] && \\
        . "$HOME/.repair-manager/init.sh"
"#;
    let fixture = DoctorFixture::new(manifest);
    let bashenv_path = fixture.bashenv_path();
    fs::write(&bashenv_path, "export EXISTING_VAR=1\n").expect("failed to seed bashenv");

    let backup_path = fixture.home().join(".substrate_bashenv.bak");
    let run_repair = || {
        fixture
            .command()
            .arg("shim")
            .arg("repair")
            .arg("--manager")
            .arg("RepairManager")
            .arg("--yes")
            .output()
            .expect("failed to run shim repair")
    };

    let first = run_repair();
    assert!(
        first.status.success(),
        "expected shim repair to succeed on first run:\nstdout: {}\nstderr: {}",
        String::from_utf8_lossy(&first.stdout),
        String::from_utf8_lossy(&first.stderr)
    );

    let content = fs::read_to_string(&bashenv_path).expect("failed to read bashenv after repair");
    assert!(
        content.contains("export EXISTING_VAR=1"),
        "existing bashenv lines should be preserved: {content}"
    );
    assert!(
        content.contains("Substrate repair for RepairManager"),
        "repair snippet missing from bashenv: {content}"
    );
    assert!(
        content.matches("REPAIR_MANAGER=1").count() == 1,
        "repair snippet should only be appended once per run: {content}"
    );

    assert!(
        backup_path.exists(),
        "repair command must create a .substrate_bashenv.bak backup"
    );
    let backup_contents = fs::read_to_string(&backup_path).expect("failed to read bashenv backup");
    assert_eq!(
        backup_contents, "export EXISTING_VAR=1\n",
        "backup should capture the pre-repair bashenv contents"
    );

    let second = run_repair();
    assert!(
        second.status.success(),
        "expected shim repair to remain idempotent:\nstdout: {}\nstderr: {}",
        String::from_utf8_lossy(&second.stdout),
        String::from_utf8_lossy(&second.stderr)
    );
    let second_contents =
        fs::read_to_string(&bashenv_path).expect("failed to read bashenv after second repair");
    assert_eq!(
        content, second_contents,
        "running repair twice should not duplicate the snippet"
    );
}
