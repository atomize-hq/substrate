#![cfg(unix)]

use assert_cmd::Command;
use serde_json::{json, Value};
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as StdCommand;
use std::sync::OnceLock;
use tempfile::{Builder, TempDir};

/// Return an `assert_cmd::Command` pre-configured to run `substrate`
/// in host-only mode. This helper ensures we reuse the already-built binary,
/// sets a shared TMPDIR for deterministic fixtures, and propagates the
/// `SUBSTRATE_WORLD`/`SUBSTRATE_WORLD_ENABLED` overrides that bypass world init.
pub fn substrate_shell_driver() -> Command {
    ensure_substrate_built();

    let mut cmd = Command::new(binary_path());
    cmd.env("TMPDIR", shared_tmpdir());
    cmd.env("SUBSTRATE_WORLD", "disabled");
    cmd.env("SUBSTRATE_WORLD_ENABLED", "0");
    cmd.env_remove("SUBSTRATE_WORLD_ID");
    cmd
}

/// Shared temp directory root so every test writes into `target/tests-tmp`.
pub fn shared_tmpdir() -> &'static Path {
    static TMP: OnceLock<PathBuf> = OnceLock::new();
    TMP.get_or_init(|| {
        let base = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../target/tests-tmp");
        fs::create_dir_all(&base).expect("failed to create shared TMPDIR");
        std::env::set_var("TMPDIR", &base);
        base
    })
}

/// Allocate a temporary directory with a descriptive prefix under the shared root.
pub fn temp_dir(prefix: &str) -> TempDir {
    Builder::new()
        .prefix(prefix)
        .tempdir_in(shared_tmpdir())
        .expect("failed to allocate integration test temp dir")
}

pub fn ensure_substrate_built() {
    static BUILD_ONCE: OnceLock<()> = OnceLock::new();
    BUILD_ONCE.get_or_init(|| {
        let status = StdCommand::new("cargo")
            .args(["build", "-p", "substrate"])
            .status()
            .expect("failed to invoke cargo build -p substrate");
        assert!(status.success(), "cargo build -p substrate failed");
    });
}

pub fn binary_path() -> String {
    let binary_name = if cfg!(windows) {
        "substrate.exe"
    } else {
        "substrate"
    };

    if let Ok(workspace_dir) = std::env::var("CARGO_WORKSPACE_DIR") {
        format!("{workspace_dir}/target/debug/{binary_name}")
    } else {
        format!("../../target/debug/{binary_name}")
    }
}

/// Shared helpers for shim doctor/health integration tests.
pub mod doctor_fixture {
    use super::*;

    pub struct DoctorFixture {
        _temp: TempDir,
        home: PathBuf,
        manifest: PathBuf,
        trace: PathBuf,
        shim_dir: PathBuf,
        health_dir: PathBuf,
    }

    impl DoctorFixture {
        pub fn new(manifest_contents: &str) -> Self {
            let temp = super::temp_dir("substrate-doctor-");
            let home = temp.path().join("home");
            let shim_dir = home.join(".substrate/shims");
            fs::create_dir_all(&shim_dir).expect("failed to prepare shim directory");
            let trace = home.join(".substrate/trace.jsonl");
            fs::create_dir_all(trace.parent().unwrap()).expect("failed to create trace dir");
            fs::write(&trace, "").expect("failed to create trace log placeholder");
            let manager_init = home.join(".substrate/manager_init.sh");
            fs::write(&manager_init, "# Generated by shim doctor tests\n")
                .expect("failed to seed manager init file");
            let manifest = home.join("manager_hooks.yaml");
            fs::write(&manifest, manifest_contents).expect("failed to write manifest");
            let health_dir = home.join(".substrate/health");
            fs::create_dir_all(&health_dir).expect("failed to create health fixture dir");
            let fixture = Self {
                _temp: temp,
                home,
                manifest,
                trace,
                shim_dir,
                health_dir,
            };
            fixture.write_default_world_fixtures();
            fixture
        }

        fn write_default_world_fixtures(&self) {
            self.write_world_doctor_fixture(json!({
                "platform": "test-fixture",
                "ok": true,
                "message": "fixture"
            }));
            self.write_world_deps_fixture(json!({
                "manifest": {
                    "base": self.home.join(".substrate/world-deps.yaml"),
                    "overlay": null,
                    "overlay_exists": false
                },
                "world_disabled_reason": null,
                "tools": []
            }));
        }

        pub fn write_world_doctor_fixture(&self, value: Value) {
            let path = self.health_dir.join("world_doctor.json");
            fs::write(&path, value.to_string()).expect("failed to write world doctor fixture");
        }

        pub fn write_world_deps_fixture(&self, value: Value) {
            let path = self.health_dir.join("world_deps.json");
            fs::write(&path, value.to_string()).expect("failed to write world deps fixture");
        }

        pub fn command(&self) -> Command {
            let mut cmd = super::substrate_shell_driver();
            cmd.env("HOME", &self.home)
                .env("USERPROFILE", &self.home)
                .env("SUBSTRATE_MANAGER_MANIFEST", &self.manifest)
                .env("SHIM_TRACE_LOG", &self.trace);
            cmd
        }

        pub fn home(&self) -> &Path {
            &self.home
        }

        pub fn shim_dir(&self) -> &Path {
            &self.shim_dir
        }

        pub fn bashenv_path(&self) -> PathBuf {
            self.home.join(".substrate_bashenv")
        }

        pub fn write_hint_event(&self, name: &str, hint: &str, ts: &str) {
            let event = json!({
                "ts": ts,
                "event_type": "command_complete",
                "component": "shim",
                "manager_hint": {
                    "name": name,
                    "hint": hint,
                    "pattern": ".*",
                    "ts": ts,
                }
            });
            let mut file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.trace)
                .expect("failed to open trace log for append");
            writeln!(file, "{}", event.to_string()).expect("failed to write hint event");
        }

        pub fn health_dir(&self) -> &Path {
            &self.health_dir
        }
    }
}
