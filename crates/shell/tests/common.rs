#![cfg(unix)]

use assert_cmd::Command;
use serde_json::{json, Value};
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as StdCommand;
use std::sync::OnceLock;
use tempfile::{Builder, TempDir};

/// Return an `assert_cmd::Command` pre-configured to run `substrate`
/// in host-only mode. This helper ensures we reuse the already-built binary,
/// sets a shared TMPDIR for deterministic fixtures, and propagates the
/// `SUBSTRATE_OVERRIDE_WORLD=disabled` override that bypasses world init.
pub fn substrate_shell_driver() -> Command {
    ensure_substrate_built();

    let mut cmd = Command::new(binary_path());
    cmd.env("TMPDIR", shared_tmpdir());
    // Ensure tests are deterministic even when run from inside the shimmed substrate shell.
    cmd.env_remove("SHIM_ORIGINAL_PATH");
    cmd.env_remove("SUBSTRATE_WORLD");
    cmd.env_remove("SUBSTRATE_WORLD_ENABLED");
    cmd.env("SUBSTRATE_OVERRIDE_WORLD", "disabled");
    cmd.env_remove("SUBSTRATE_WORLD_ID");
    cmd
}

/// Shared temp directory root so every test writes into `target/tests-tmp`.
pub fn shared_tmpdir() -> &'static Path {
    static TMP: OnceLock<PathBuf> = OnceLock::new();
    TMP.get_or_init(|| {
        let base = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../target/tests-tmp");
        fs::create_dir_all(&base).expect("failed to create shared TMPDIR");
        std::env::set_var("TMPDIR", &base);
        base
    })
}

/// Allocate a temporary directory with a descriptive prefix under the shared root.
pub fn temp_dir(prefix: &str) -> TempDir {
    Builder::new()
        .prefix(prefix)
        .tempdir_in(shared_tmpdir())
        .expect("failed to allocate integration test temp dir")
}

pub fn ensure_substrate_built() {
    static BUILD_ONCE: OnceLock<()> = OnceLock::new();
    BUILD_ONCE.get_or_init(|| {
        let status = StdCommand::new("cargo")
            .args(["build", "-p", "substrate"])
            .status()
            .expect("failed to invoke cargo build -p substrate");
        assert!(status.success(), "cargo build -p substrate failed");
    });
}

pub fn binary_path() -> String {
    let binary_name = if cfg!(windows) {
        "substrate.exe"
    } else {
        "substrate"
    };

    if let Ok(workspace_dir) = std::env::var("CARGO_WORKSPACE_DIR") {
        std::path::PathBuf::from(workspace_dir)
            .join("target")
            .join("debug")
            .join(binary_name)
            .to_string_lossy()
            .into_owned()
    } else {
        std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../target/debug")
            .join(binary_name)
            .to_string_lossy()
            .into_owned()
    }
}

/// Shared helpers for shim doctor/health integration tests.
#[allow(dead_code)]
pub mod doctor_fixture {
    use super::*;

    #[allow(dead_code)]
    pub struct DoctorFixture {
        _temp: TempDir,
        home: PathBuf,
        manifest: PathBuf,
        trace: PathBuf,
        shim_dir: PathBuf,
        health_dir: PathBuf,
    }

    #[allow(dead_code)]
    impl DoctorFixture {
        pub fn new(manifest_contents: &str) -> Self {
            let temp = super::temp_dir("substrate-doctor-");
            let home = temp.path().join("home");
            let shim_dir = home.join(".substrate/shims");
            fs::create_dir_all(&shim_dir).expect("failed to prepare shim directory");
            let trace = home.join(".substrate/trace.jsonl");
            fs::create_dir_all(trace.parent().unwrap()).expect("failed to create trace dir");
            fs::write(&trace, "").expect("failed to create trace log placeholder");
            let manager_init = home.join(".substrate/manager_init.sh");
            fs::write(&manager_init, "# Generated by shim doctor tests\n")
                .expect("failed to seed manager init file");
            let manifest = home.join("manager_hooks.yaml");
            fs::write(&manifest, manifest_contents).expect("failed to write manifest");
            let health_dir = home.join(".substrate/health");
            fs::create_dir_all(&health_dir).expect("failed to create health fixture dir");
            let fixture = Self {
                _temp: temp,
                home,
                manifest,
                trace,
                shim_dir,
                health_dir,
            };
            fixture.write_default_world_fixtures();
            fixture
        }

        fn write_default_world_fixtures(&self) {
            self.write_world_doctor_fixture(json!({
                "schema_version": 1,
                "platform": std::env::consts::OS,
                "world_enabled": true,
                "ok": true,
                "host": {
                    "platform": std::env::consts::OS,
                    "ok": true,
                    "world_fs_mode": "writable",
                    "world_fs_isolation": "workspace",
                    "world_fs_require_world": true
                },
                "world": {
                    "status": "ok",
                    "schema_version": 1,
                    "ok": true,
                    "collected_at_utc": "2026-01-08T00:00:00Z",
                    "landlock": {
                        "supported": true,
                        "abi": 3,
                        "reason": null
                    },
                    "world_fs_strategy": {
                        "primary": "overlay",
                        "fallback": "fuse",
                        "probe": {
                            "id": "enumeration_v1",
                            "probe_file": ".substrate_enum_probe",
                            "result": "pass",
                            "failure_reason": null
                        }
                    }
                }
            }));
            self.write_world_deps_fixture(json!({
                "manifest": {
                    "inventory": {
                        "base": self.home.join("manager_hooks.yaml"),
                        "overlay": self.home.join(".substrate/manager_hooks.local.yaml"),
                        "overlay_exists": false
                    },
                    "overlays": {
                        "installed": self.home.join(".substrate/world-deps.yaml"),
                        "installed_exists": false,
                        "user": self.home.join(".substrate/world-deps.local.yaml"),
                        "user_exists": false
                    },
                    "layers": [
                        self.home.join("manager_hooks.yaml"),
                        self.home.join(".substrate/manager_hooks.local.yaml"),
                        self.home.join(".substrate/world-deps.yaml"),
                        self.home.join(".substrate/world-deps.local.yaml")
                    ]
                },
                "world_disabled_reason": null,
                "tools": []
            }));
        }

        pub fn write_world_doctor_fixture(&self, value: Value) {
            let path = self.health_dir.join("world_doctor.json");
            fs::write(&path, value.to_string()).expect("failed to write world doctor fixture");
        }

        pub fn write_world_deps_fixture(&self, value: Value) {
            let path = self.health_dir.join("world_deps.json");
            fs::write(&path, value.to_string()).expect("failed to write world deps fixture");
        }

        pub fn command(&self) -> Command {
            let mut cmd = super::substrate_shell_driver();
            cmd.env("HOME", &self.home)
                .env("USERPROFILE", &self.home)
                .current_dir(&self.home)
                .env("SUBSTRATE_HOME", self.home.join(".substrate"))
                .env("SUBSTRATE_MANAGER_MANIFEST", &self.manifest)
                .env("SHIM_TRACE_LOG", &self.trace);
            cmd
        }

        pub fn home(&self) -> &Path {
            &self.home
        }

        pub fn shim_dir(&self) -> &Path {
            &self.shim_dir
        }

        pub fn bashenv_path(&self) -> PathBuf {
            self.home.join(".substrate_bashenv")
        }

        #[allow(clippy::to_string_in_format_args)]
        pub fn write_hint_event(&self, name: &str, hint: &str, ts: &str) {
            let event = json!({
                "ts": ts,
                "event_type": "command_complete",
                "component": "shim",
                "manager_hint": {
                    "name": name,
                    "hint": hint,
                    "pattern": ".*",
                    "ts": ts,
                }
            });
            let mut file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.trace)
                .expect("failed to open trace log for append");
            writeln!(file, "{}", event).expect("failed to write hint event");
        }

        pub fn health_dir(&self) -> &Path {
            &self.health_dir
        }
    }
}
