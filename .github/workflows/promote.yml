name: Promote to Main

on:
  workflow_dispatch:
    inputs:
      next_version:
        description: Optional override for the next release version (defaults to auto bump)
        required: false
        default: ""
      dry_run:
        description: Set true to preview without pushing changes
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  statuses: write

jobs:
  promote:
    runs-on: ubuntu-22.04
    env:
      DRY_RUN: ${{ inputs.dry_run }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Configure Git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine next version/tag
        id: determine_version
        env:
          REQUESTED_VERSION: ${{ inputs.next_version }}
        run: |
          set -euo pipefail
          git fetch --tags --force origin

          if [ -n "${REQUESTED_VERSION}" ]; then
            NEXT_VERSION="${REQUESTED_VERSION}"
            SOURCE="workflow_input"
          else
            LAST_TAG=$(git describe --tags --match 'v[0-9]*.[0-9]*.[0-9]*' --abbrev=0 2>/dev/null || true)
            if [ -z "${LAST_TAG}" ]; then
              CURRENT=$(cargo metadata --no-deps --format-version 1 \
                | jq -r '.packages[] | select(.name == "substrate") | .version' \
                | head -n1)
              if [ -z "${CURRENT}" ]; then
                echo "Unable to determine existing version for auto bump" >&2
                exit 1
              fi
              LAST_TAG="v${CURRENT}"
            fi

            VERSION_BODY="${LAST_TAG#v}"
            IFS='.' read -r major minor patch <<<"${VERSION_BODY}"
            if [ -z "${major}" ] || [ -z "${minor}" ] || [ -z "${patch}" ]; then
              echo "Unable to parse version from ${LAST_TAG}" >&2
              exit 1
            fi
            patch=$((patch + 1))
            NEXT_VERSION="${major}.${minor}.${patch}"
            SOURCE="auto_patch_increment"
          fi

          if ! [[ "${NEXT_VERSION}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
            echo "Next version '${NEXT_VERSION}' is not a valid SemVer string" >&2
            exit 1
          fi

          echo "next_version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag_name=v${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "version_source=${SOURCE}" >> "$GITHUB_OUTPUT"

      - name: Prepare push credentials
        if: ${{ env.DRY_RUN != 'true' }}
        env:
          PROMOTE_PUSH_TOKEN: ${{ secrets.PROMOTE_PUSH_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${PROMOTE_PUSH_TOKEN:-}" ]; then
            echo "PROMOTE_PUSH_TOKEN secret is required for promotion pushes." >&2
            exit 1
          fi
          git remote set-url origin "https://x-access-token:${PROMOTE_PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

      - name: Bump versions on testing
        id: bump
        env:
          NEXT_VERSION: ${{ steps.determine_version.outputs.next_version }}
          DRY_RUN: ${{ env.DRY_RUN }}
        run: |
          set -euo pipefail
          git fetch origin testing
          git checkout testing
          git reset --hard origin/testing
          
          CURRENT_VERSION=$(cargo metadata --no-deps --format-version 1 \
            | jq -r '.packages[] | select(.name == "substrate") | .version' \
            | head -n1)

          if [ -z "${CURRENT_VERSION}" ]; then
            echo "Unable to resolve current substrate version from cargo metadata." >&2
            exit 1
          fi

          echo "current_version=${CURRENT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "next_version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"

          ORIGINAL_SHA=$(git rev-parse HEAD)

          if [ "${NEXT_VERSION}" = "${CURRENT_VERSION}" ]; then
            echo "Next version matches current version; skipping version bump."
            echo "testing_sha=${ORIGINAL_SHA}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "${DRY_RUN}" = "true" ]; then
            cargo run -p version-bump -- --current-version "${CURRENT_VERSION}" --next-version "${NEXT_VERSION}" --dry-run
            echo "testing_sha=${ORIGINAL_SHA}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          cargo run -p version-bump -- --current-version "${CURRENT_VERSION}" --next-version "${NEXT_VERSION}"
          cargo generate-lockfile

          if git diff --quiet; then
            echo "No changes detected after version bump."
            echo "testing_sha=${ORIGINAL_SHA}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git status --short
          git add --all

          if git diff --cached --quiet; then
            echo "No staged changes detected; skipping commit."
            echo "testing_sha=${ORIGINAL_SHA}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore: release ${NEXT_VERSION}"
          git push origin HEAD:testing

          NEW_SHA=$(git rev-parse HEAD)
          echo "testing_sha=${NEW_SHA}" >> "$GITHUB_OUTPUT"
          echo "version_commit=${NEW_SHA}" >> "$GITHUB_OUTPUT"

      - name: Ensure latest testing CI run succeeded
        id: ci-status
        uses: actions/github-script@v7
        env:
          TARGET_SHA: ${{ steps.bump.outputs.testing_sha }}
          DRY_RUN: ${{ env.DRY_RUN }}
          CI_WINDOW_MINUTES: "45"
        with:
          script: |
            const {owner, repo} = context.repo;
            const windowMinutes = parseInt(process.env.CI_WINDOW_MINUTES || "30", 10);
            const now = Date.now();
            const response = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: "ci-testing.yml",
              per_page: 30,
            });

            const runs = response.data.workflow_runs || [];

            const isTestingBase = async (run) => {
              if (run.head_branch === "testing") {
                return true;
              }
              if (run.event === "pull_request" && run.head_branch) {
                const prs = await github.rest.pulls.list({
                  owner,
                  repo,
                  state: "all",
                  head: `${owner}:${run.head_branch}`,
                });
                return prs.data.some(pr => pr.base.ref === "testing");
              }
              return false;
            };

            let freshRun = null;
            for (const run of runs) {
              if (run.status !== "completed" || run.conclusion !== "success") {
                continue;
              }
              const updated = new Date(run.updated_at).getTime();
              if (now - updated > windowMinutes * 60 * 1000) {
                continue;
              }
              if (await isTestingBase(run)) {
                freshRun = run;
                break;
              }
            }

            if (!freshRun) {
              core.setFailed(`No successful ci-testing.yml run found in the last ${windowMinutes} minutes. Re-run CI on 'testing' before promoting.`);
              return;
            }

            core.info(`Using ci-testing.yml run ${freshRun.id} (${freshRun.head_sha}) completed at ${freshRun.updated_at}.`);
            core.setOutput("ci_url", freshRun.html_url);
            core.setOutput("ci_conclusion", freshRun.conclusion);
            core.setOutput("ci_run_id", freshRun.id.toString());
            core.setOutput("ci_sha", freshRun.head_sha);

      - name: Mark promotion status
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_SHA: ${{ steps.bump.outputs.testing_sha }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          github-token: ${{ github.token }}
          script: |
            const targetSha = process.env.TARGET_SHA;
            const runUrl = process.env.RUN_URL;
            if (!targetSha) {
              core.setFailed("Cannot set promotion status without target SHA.");
              return;
            }
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: targetSha,
              state: "success",
              context: "Promote to Main",
              description: "Promotion workflow ready to fast-forward main",
              target_url: runUrl,
            });

      - name: Fast-forward main to testing
        id: fast-forward
        run: |
          set -euo pipefail
          git fetch origin main testing
          BEFORE_MAIN=$(git rev-parse origin/main)
          SOURCE_SHA=$(git rev-parse origin/testing)
          git checkout main
          git merge --ff-only origin/testing

          if [ "${DRY_RUN}" != "true" ]; then
            git push origin main
          else
            echo "Dry run enabled; skipping push to origin/main."
          fi

          echo "before_main=${BEFORE_MAIN}" >> "$GITHUB_OUTPUT"
          echo "source_sha=${SOURCE_SHA}" >> "$GITHUB_OUTPUT"
          echo "new_main=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Create release tag
        if: ${{ steps.determine_version.outputs.tag_name != '' }}
        env:
          TAG_NAME: ${{ steps.determine_version.outputs.tag_name }}
          DRY_RUN: ${{ env.DRY_RUN }}
        run: |
          set -euo pipefail
          if [ "${DRY_RUN}" == "true" ]; then
            echo "Dry run enabled; skipping tag creation for ${TAG_NAME}."
            exit 0
          fi

          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Aborting." >&2
            exit 1
          fi

          git tag -a "${TAG_NAME}" -m "Promotion ${TAG_NAME}"
          git push origin "${TAG_NAME}"

      - name: Trigger release workflow
        if: ${{ env.DRY_RUN != 'true' }}
        env:
          RELEASE_TAG: ${{ steps.determine_version.outputs.tag_name }}
          PROMOTE_PUSH_TOKEN: ${{ secrets.PROMOTE_PUSH_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${PROMOTE_PUSH_TOKEN}" ]; then
            echo "PROMOTE_PUSH_TOKEN is required to dispatch release.yml" >&2
            exit 1
          fi
          export GH_TOKEN="${PROMOTE_PUSH_TOKEN}"
          gh workflow run release.yml --ref "refs/tags/${RELEASE_TAG}"

      - name: Promotion summary
        env:
          DRY_RUN: ${{ env.DRY_RUN }}
          TAG_NAME: ${{ steps.determine_version.outputs.tag_name }}
          CURRENT_VERSION: ${{ steps.bump.outputs.current_version }}
          NEXT_VERSION: ${{ steps.bump.outputs.next_version }}
          VERSION_COMMIT: ${{ steps.bump.outputs.version_commit }}
          TESTING_SHA: ${{ steps.fast-forward.outputs.source_sha }}
          BEFORE_MAIN: ${{ steps.fast-forward.outputs.before_main }}
          NEW_MAIN: ${{ steps.fast-forward.outputs.new_main }}
          CI_URL: ${{ steps.ci-status.outputs.ci_url }}
        run: |
          {
            echo "## Promotion Summary"
            echo ""
            echo "- Dry run: \`${DRY_RUN}\`"
            echo "- Triggered from ref: \`${GITHUB_REF}\`"
            echo "- Source (testing) tip: \`${TESTING_SHA}\`"
            echo "- Previous main: \`${BEFORE_MAIN}\`"
            echo "- New main head: \`${NEW_MAIN}\`"
            if [ -n "${CI_URL}" ]; then
              echo "- Latest testing CI: [link](${CI_URL})"
            else
              echo "- Latest testing CI: (not available)"
            fi
            if [ -n "${CURRENT_VERSION}" ] && [ -n "${NEXT_VERSION}" ] && [ "${NEXT_VERSION}" != "${CURRENT_VERSION}" ]; then
              if [ -n "${VERSION_COMMIT}" ]; then
                echo "- Version bump: ${CURRENT_VERSION} → ${NEXT_VERSION} (commit \`${VERSION_COMMIT}\`)"
              else
                echo "- Version bump: ${CURRENT_VERSION} → ${NEXT_VERSION} (dry run)"
              fi
            else
              echo "- Version bump: not performed"
            fi
            if [ -n "${TAG_NAME}" ]; then
              echo "- Tag created: \`${TAG_NAME}\`"
            fi
            if [ "${DRY_RUN}" == "true" ]; then
              echo ""
              echo "> ⚠️ Dry run requested – no pushes or tags were published."
            fi
          } >> "$GITHUB_STEP_SUMMARY"
